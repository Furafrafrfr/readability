# 普遍的なソフトウェア設計原則：保守性と再利用性を高めるために

高品質で保守しやすく、テストが容易なソフトウェアを構築するための核心は、**「何をするか（What）」**を定義する**コアロジック**と、**「それをどう実行するか（How）」**を担う**環境依存のコード**を明確に分離することにあります。この原則は、クリーンアーキテクチャやヘキサゴナルアーキテクチャなど、多くの近代的な設計思想の基礎となっています。

## 1. コアロジック（ビジネスロジック）

### 1.1. コアロジックとは？

アプリケーションの**本質的な価値**そのものです。ビジネスルール、計算、データ変換、検証など、実行環境（Web、サーバー、モバイルなど）に依存しない、アプリケーションの心臓部となるロジックを指します。

* **性質**: 純粋(Pure)、状態を持たない(Stateless)、普遍的(Universal)
* **役割**: アプリケーションの「脳」。データを受け取り、ルールに基づいて処理し、結果を返します。
* **具体例**:
    * ショッピングカートの合計金額を計算するロジック
    * ユーザーパスワードの複雑性を検証するルール
    * 特定の基準に基づいてデータを並べ替える処理
    * テキスト形式のレポートを生成するロジック

### 1.2. コアロジックの実装原則

* **原則1：純粋な関数として振る舞う**
    同じ入力に対しては、必ず同じ出力を返すように設計します。外部APIの呼び出し、データベースへのアクセス、現在時刻の取得といった、結果が変動する可能性のある処理や、外部システムに影響を与える「副作用」を直接含めてはいけません。

* **原則2：状態を持たない（ステートレス）**
    ロジック自身が内部に状態を保持するべきではありません。必要なデータはすべて引数として受け取り、処理結果は新しいデータとして返却します。これにより、処理の流れが追いやすくなり、予測可能性が高まります。

* **原則3：依存は「抽象」にのみ行う（依存性逆転の原則）**
    外部の機能（例: データ保存、通知送信）が必要な場合、その具体的な実装（例: 特定のデータベースライブラリ）に直接依存してはいけません。代わりに、抽象的な「インターフェース（契約）」を定義し、それに依存します。これにより、具体的な技術が変更されてもコアロジックは影響を受けません。

* **原則4：明確なデータ構造（コントラクト）**
    入力と出力のデータ構造を、スキーマやデータ転送オブジェクト（DTO）などで明確に定義します。これがコアロジックと外部との間の「契約書」となり、システムの各パーツを安全に接続するのに役立ちます。

## 2. 環境依存コード（インフラストラクチャ層）

### 2.1. 環境依存コードとは？

コアロジックを、現実世界の特定の環境（Webフレームワーク、データベース、外部APIなど）に接続するための「接着剤（グルーコード）」です。**副作用を伴う処理**のほとんどがこの層に属します。

* **性質**: 不純(Impure)、状態を持つことがある(Stateful)、環境固有(Specific)
* **役割**: アプリケーションの「手足」。ユーザーインターフェースからの入力を受け取ったり、データベースに問い合わせたり、結果を画面に表示したりします。
* **具体例**:
    * **UI関連**: DOM操作、UIフレームワークの状態管理、イベントハンドリング
    * **I/O処理**: HTTPクライアントによるAPI呼び出し、ファイルシステムへの読み書き、データベースへのクエリ発行
    * **インフラ連携**: 環境変数の読み取り、メッセージキューへの接続

### 2.2. 環境依存コードの実装原則

* **原則1：単一の責務を持つ**
    そのコードの役割を一つに絞ります。「APIからデータを取得する」「UIイベントを監視する」など、特定の環境における特定の処理のみを担当させます。

* **原則2：コアロジックの呼び出しに徹する**
    環境から受け取った入力をコアロジックが扱いやすい形式に整えて渡し、コアロジックから返された結果を環境（UI、DBなど）に出力します。**この層にビジネスルールを記述してはいけません。**

* **原則3：抽象インターフェースを実装する**
    コアロジックが定義したインターフェース（例: `UserRepository`）の**具体的な実装**を提供します（例: `PostgresUserRepository`）。これにより、コアロジックと疎結合な関係を保ちます。

## 3. 両者の連携：依存性の注入（Dependency Injection）

これら2つの世界は、アプリケーションの最上位層（エントリーポイントや起動ファイル）で**「組み立て（Composition）」**られます。

具体的には、**依存性の注入（DI）**というテクニックを用います。これは、コアロジックが必要とする抽象インターフェース（例: `DataFetcher`）に対して、環境依存コードで作成した具体的な実装（例: `ApiFetcher`）のインスタンスを外部から「注入」することです。

このアプローチにより、コアロジックはどの環境で実行されているかを意識する必要がなくなり、極めて高い再利用性とテスト容易性を実現します。

## 4. 実践的な開発手法：テスト駆動開発（TDD）

この設計原則を実践する上で、テスト駆動開発（TDD）は非常に有効な開発手法です。

* **TDDのサイクル：「レッド・グリーン・リファクター」**
    1.  **レッド**: まず、失敗するテストコードを書きます。これは、これから実装する機能の「仕様」をコードで表現する行為です。
    2.  **グリーン**: 次に、そのテストを通過させるための最小限のコードを実装します。
    3.  **リファクター**: 最後に、テストが通った状態を維持しながら、コードの構造をよりクリーンで分かりやすいものに改善します。

この短いサイクルを繰り返すことで、常に動作が保証された状態で、自信を持ってコードの改善を進めることができます。特に、副作用のないコアロジックはTDDと非常に相性が良く、ロジックの正しさを容易に検証できます。
